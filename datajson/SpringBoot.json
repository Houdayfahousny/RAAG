{
  "text": " \n \n\nPlan: \n\nWhy Spring Boot?\nSpring vs Spring Boot\nSpring Boot Annotations\nSpring Boot Starters\nDemo (Spring Setup)\nTests\nDemo (Tests)\nMaterials & documentation\nPlan: \n\nWhy Spring Boot?\nSpring vs Spring Boot\nSpring Boot Annotations\nSpring Boot Starters\nDemo (Spring Setup)\nTests\nDemo (Tests)\nMaterials & documentation\n\nYou can choose Spring Boot because of the features and benefits it offers :\nCreate stand-alone Spring applications\nTo avoid complex XML configuration in Spring\nTo develop a production ready Spring applications in an easier way\nIn Spring Boot, everything is auto configured (no manual configurations are needed).\nIt offers annotation-based spring application\nEases dependency management\nProvide starter dependencies to simplify your build configuration\nIt includes an Embedded Servlet Container (Tomcat)\nReduces the development time\nProvide production-ready features such as metrics, health checks, and externalised configuration\nWhy Spring Boot?\nPlan: \n\nWhy Spring Boot?\nSpring vs Spring Boot\nSpring Boot Annotations\nSpring Boot Starters\nDemo (Spring Setup)\nTests\nDemo (Tests)\nMaterials & documentation\nDefinition : Spring vs Spring Boot\n\n\nSpring :\nTo put it simply, the Spring framework provides comprehensive infrastructure support for developing Java applications.\nIt's packed with some useful features like Dependency Injection, and out of the box modules, that can drastically reduce the development time of an application, like: Spring MVC, Spring Test, Spring Security..\n\nSpring vs Spring Boot\nDefinition : Spring vs Spring Boot\n\n\nSpring Boot :\nOn the other hand, Spring Boot is basically an extension of the Spring framework, which eliminates the boilerplate configurations required for setting up a Spring application.\nSince Spring Boot is built on top of Spring, it offers all the features and benefits of Spring. \nSpring Boot aims to reduce code length and provides developers with the easiest way to build an application.\nSpring vs Spring Boot\nDependencies : Spring vs Spring Boot\n\n\nSpring :\nthe minimum dependencies required to create a web application using Spring are :\n\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-web</artifactId>\n    <version>x.x.x</version>\n</dependency>\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-webmvc</artifactId>\n    <version>x.x.x</version>\n</dependency>\n\nSpring vs Spring Boot\nDependencies : Spring vs Spring Boot\n\n\nSpring Boot :\n\nSpring Boot requires only one dependency to get a web application up and running :\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n    <version>x.x.x</version>\n</dependency>\nSpring vs Spring Boot\nBootstrapping : Spring vs Spring Boot\n\n\nSpring :\nSpring supports both the legacy web.xml way of bootstrapping as well as the Servlet method.\nXML approach (web.xml) :\nServlet container (the server) reads web.xml.\nThe DispatcherServlet defined in the web.xml is instantiated by the container.\nDispatcherServlet creates WebApplicationContext by reading WEB-INF/{dispatcherServletName}-servlet.xml.\nFinally, the DispatcherServlet registers the beans defined in the application context.\nJava approach : \nThe container searches for classes implementing ServletContainerInitializer ⇒ SpringServletContainerInitializer \nThe SpringServletContainerInitializer class (which implements ServletContainerInitializer) finds all classes implementing WebApplicationInitializer.\nThe WebApplicationInitializer creates the context with XML or @Configuration classes.\nThe WebApplicationInitializer creates the DispatcherServlet with the previously created context.\n\t\t⇒ https://www.codejava.net/frameworks/spring/bootstrapping-a-spring-web-mvc-application-programmatically \nSpring vs Spring Boot\nBootstrapping : Spring vs Spring Boot\n\nSpring Boot :\nThe entry point of a Spring Boot application is the class which is annotated with @SpringBootApplication.\nBy default, Spring Boot uses an embedded container to run the application. In this case, Spring Boot uses the public static void main entry point to launch an embedded web server.\nAnother feature of Spring Boot is that it automatically scans all the classes in the same package or sub packages of the Main-class, for components.\n\nSpring vs Spring Boot\nPlan: \n\nWhy Spring Boot?\nSpring vs Spring Boot\nSpring Boot Annotations\nSpring Boot Starters\nDemo (Spring Setup)\nTests\nDemo (Tests)\nMaterials & documentation\n\nSpring Boot Annotations is a form of metadata that provides data about a program. \nIn other words, annotations are used to provide supplemental information about a program. \n\nSpring Boot Annotations\n@SpringBootApplication\n\nIt’s an essential annotation to all Spring Boot applications.\n@SpringBootApplication replaces several other key annotations :\n@Configuration\n@ComponentScan\n@EnableAutoConfiguration\n\nThe class annotated with @SpringBootApplication is kept in the base package. \nThis annotation does the component scan. However, only the sub-packages are scanned. \nSpring Boot Annotations\n@Configuration\nNow replaced by @SpringBootApplication\n@Configuration enables Java configuration and lets you use Spring Beans in the class.\nA class annotated with the @Configuration annotation indicates that this class declares one or more @Bean\nSpring Boot Annotations\n@ComponentScan\nAlso replaced by @SpringBootApplication\n@ComponentScan is used to scan a package for beans.\nIt is used with the annotation @Configuration to allow Spring to know the packages to be scanned for annotated components. So that they can be automatically discovered and registered as beans in Spring's Application Context.\nThis annotation is also used to specify base packages.\nSpring Boot Annotations\n@EnableAutoConfiguration\nThe final annotation replaced by @SpringBootApplication\n@EnableAutoConfiguration enables Spring Boot’s auto configuration. \nIt is placed in the main application class. \nBased on the dependencies in the classpath, other beans, and various property settings, this annotation instructs Spring Boot to start adding beans.\nSpring Boot Annotations\n@Component\nIt is a class-level annotation that turns the class into Spring bean at the auto-scan time.\n@Repository, @Controller, and @Service are move specific alternatives to @Component.\nSpring Boot Annotations\n@Service\nIt is used at the class level. \nIt shows that the annotated class is part of your service layer, that contains business basic logic, and may include calls to external APIs. \nSpring Boot Annotations\n@Repository\nThis annotation marks a class as part of your persistence layer\nIt is a Data Access Object (DAO) that accesses the database directly to handle storage, retrieval, and search of data. \nSpring Boot Annotations\n@Controller\nThe annotation is used to indicate that the class is a web request handler.\n@Controller is a specialised @Component marked as a controller in the MVC architecture. \nIt is most commonly used with @RequestMapping annotation. \nSpring Boot Annotations\n@RequestBody \nThe @RequestBody annotation maps the HttpRequest body to an object, enabling automatic deserialization of the inbound HttpRequest body onto a Java object.\nBy default, the type we annotate with the @RequestBody annotation must correspond to the JSON sent from our client-side controller.\nSpring Boot Annotations\n@ResponseBody \nThe @ResponseBody annotation tells a controller that the object returned is automatically serialized into JSON and passed back into the HttpResponse object.\nSpring Boot Annotations\n@RestController \n@RestController is a specialized version of the controller. It includes the @Controller and @ResponseBody annotations.\n@RestController classes return objects instead of views.\nSo every request handling method of the controller class, automatically serializes returned objects into HttpResponse.\nSpring Boot Annotations\n@RequestParam \nIt is used to extract the query parameters from the URL. \nIt can specify default values if the query parameter is not present in the URL (if it’s not a required parameter).\nExample : http://localhost:8080/employees/search?id=123&name=sara\n\nSpring Boot Annotations\n@PathVariable \nIt is used to extract the values from the URL. \nIt is most suitable for the RESTful web service, where the URL contains a path variable. \nWe can define multiple @PathVariable in a method.\nExample : http://localhost:8080/employees/search/123/test/\nSpring Boot Annotations\n@RequestHeader \nIt is used to get the details about the HTTP request headers. \nWe use this annotation as a method parameter. \nWe can use it multiple time in a method\nExample : Content-Type, Accept, Authorization..\nSpring Boot Annotations\nPlan: \n\nWhy Spring Boot?\nSpring vs Spring Boot\nSpring Boot Annotations\nSpring Boot Starters\nDemo (Spring Setup)\nTests\nDemo (Tests)\nMaterials & documentation\nThe starters allow us to add jars in the classpath and they make development easier and rapid. \nSpring Boot Starters are dependency descriptors that can be added under the <dependencies> section in pom.xml. \nIn the Spring Boot Framework, all the starters follow a similar naming pattern: spring-boot-starter-*, where * denotes a particular type of application. \n⇒ For example, if we want to use Spring and JPA for database access, we need to include the spring-boot-starter-data-jpa dependency in our pom.xml file of the project.\nSpring Boot Starters\nThe advantages of using Starters are as follows:\nIncrease productivity by decreasing the Configuration time for developers.\nManaging the POM is easier since the number of dependencies to be added is decreased.\nTested, Production-ready, and supported dependency configurations.\nNo need to remember the name and version of the dependencies.\nSpring Boot Starters\nSpring Boot Starter Parent\nThe spring-boot-starter-parent project is a special starter project that provides default configurations for our application (like Java version) and a complete dependency tree to quickly build our Spring Boot project. \nIt also provides default configurations for Maven plugins, such as maven-jar-plugin and maven-war-plugin.\nBeyond that, it also inherits dependency management from spring-boot-dependencies, which is the parent to the spring-boot-starter-parent.\nWe can start using it in our project by adding it as a parent in our project's pom.xml:\n<parent>  \n<groupId>org.springframework.boot</groupId>  \n<artifactId>spring-boot-starter-parent</artifactId>  \n<version>2.x.x</version>  <!-- Spring Boot version -->\n</parent>  \nSpring Boot Starters\nSpring Boot Starter Web\nIf we want to develop a web application, we need to add the starter spring-boot-starter-web\n<dependency>  \n<groupId>org.springframework.boot</groupId>  \n<artifactId>spring-boot-starter-web</artifactId>  \n</dependency>  \n\nThe Starter of Spring web uses Spring MVC, REST and Tomcat (as a default embedded server). \n\nSpring Boot Starters\nSpring Boot Starter Web\nThe single spring-boot-starter-web dependency pulls in all dependencies related to web development :\norg.springframework.boot:spring-boot-starter\norg.springframework.boot:spring-boot-starter-tomcat\norg.springframework.boot:spring-boot-starter-json\norg.springframework:spring-web\norg.springframework:spring-webmvc\nSpring Boot Starters\nSpring Boot Starter Data JPA\nTo connect Spring applications with relational databases efficiently, Spring Boot provides spring-boot-starter-data-jpa dependency . \nThe spring-boot-starter-data-jpa internally uses the spring-data-jpa dependency.\n<dependency>  \n<groupId>org.springframework.boot</groupId>  \n<artifactId>spring-boot-starter-data-jpa</artifactId>  \n</dependency>  \n\nSpring Boot Starters\nSpring Boot Starter Actuator\nSpring Boot Actuator provides a number of features that help you ensure that your application is running well in production.\nMonitoring our app, gathering metrics, understanding traffic, or the state of our database become trivial with this dependency.\nThe main benefit of this library is that we can get production-grade tools without having to actually implement these features ourselves.\nActuator is mainly used to expose operational information about the running application through HTTP endpoints or JMX beans.\n\nSpring Boot Starters\nSpring Boot Starter Actuator\nMost applications choose exposure via HTTP, where the ID of the endpoint along with a prefix of /actuator is mapped to a URL. \nSpring Boot includes a number of built-in endpoints and lets you add your own. \n⇒ For example, the health endpoint that is  mapped to /actuator/health, provides basic application health information. ( List of available endpoints https://docs.spring.io/spring-boot/docs/3.0.x/reference/html/actuator.html#actuator.endpoints )\nTo enable Spring Boot Actuator, we just need to add the spring-boot-actuator dependency to our package manager.\n<dependency>  \n<groupId>org.springframework.boot</groupId>  \n<artifactId>spring-boot-starter-actuator</artifactId>  \n</dependency>  \n   \nSpring Boot Starters\nSpring Boot Starter Test\nThere are several different types of tests that we can write to help test and automate the health of an application. But before starting any testing, we need to integrate the testing framework.\nThe spring-boot-starter-test is the primary dependency for the test. It contains the majority of elements required for our tests.\nWith Spring Boot, we need to add a starter to our project : the spring-boot-starter-test dependency.\n<dependency>  \n<groupId>org.springframework.boot</groupId>  \n<artifactId>spring-boot-starter-test</artifactId>  \n<scope>test</scope>  \n</dependency>  \nSpring Boot Starters\nSpring Boot Starter Test\nThe spring-boot-starter-test dependency, pulls all the dependencies related to the test. After adding it, we can build up a simple unit test.\nIn the previous dependency, one thing to be noticed is that it includes the scope of test <scope>test</scope>. \nIt means when the application is bundled and packaged for deployment, any dependency that is declared with the test scopes is ignored.\nNote :\nWhen we create a simple Spring Boot application, by default, it contains the test dependency in the pom.xml file and ApplicationNameTest.java file under in the folder src/test/java.\nSpring Boot Starters\nPlan: \n\nWhy Spring Boot?\nSpring vs Spring Boot\nSpring Boot Annotations\nSpring Boot Starters\nDemo (Spring Setup)\nTests\nDemo (Tests)\nMaterials & documentation\nDEMO\nPlan: \n\nWhy Spring Boot?\nSpring vs Spring Boot\nSpring Boot Annotations\nSpring Boot Starters\nDemo (Spring Setup)\nTests\nDemo (Tests)\nMaterials & documentation\nIntegration Tests\nIntegration tests focus on integrating different layers of the application. That also means no mocking is involved.\nIdeally, we should keep the integration tests separated from the unit tests and should not run along with the unit tests. \n⇒ We can do this by using a different profile to only run the integration tests. \nA couple of reasons for doing this could be that the integration tests are time-consuming and might need an actual database to execute.\nThe integration tests need to start up a container to execute the test cases. Hence, some additional setup is required for this. But all of this is easy in Spring Boot.\nSpring Boot Tests\nIntegration Tests\n@SpringBootTest\n@AutoConfigureMockMvc\n@TestPropertySource(locations = \"classpath:application-integrationtest.properties\")\nclass StudentControllerITest {\n\n @Autowired\n private MockMvc mockMvc;\n\n @Autowired\n private StudentRepository studentRepository;\n    // write test cases here\n}\nSpring Boot Tests\nIntegration Tests\nThe @SpringBootTest annotation is useful when we need to bootstrap the entire container. It works by creating the ApplicationContext that will be utilised in our tests.\nThe @AutoConfigureMockMvc annotation enables all auto-configuration related to MockMvc.\nThe @TestPropertySource annotation helps configure the locations of properties files specific to our tests. \n⇒ Note that the property file loaded with @TestPropertySource will override the existing application.properties file.\nThe application-integrationtest.properties contains the details to configure the persistence storage :\nspring.datasource.url = jdbc:h2:mem:testIntegration\nspring.jpa.properties.hibernate.dialect = org.hibernate.dialect.H2Dialect\nIf we want to run our integration tests against another Database ex: MySQL, we can just change the above values in the properties file.\nSpring Boot Tests\nIntegration Tests\nThe test cases for the integration tests might look similar to the Controller layer unit tests :\n@Test\npublic void itShouldGetAllStudents() throws Exception {\n\n // given\n Student student = new Student(\"sara\", \"bayour\", \"sara@nttdata.com\");\n studentRepository.save(student);\n\n // when\n ResultActions resultActions = mockMvc.perform(get(\"/students\"));\n\n // then\n MvcResult result = resultActions.andExpect(status().is2xxSuccessful())\n         .andExpect(view().name(\"students\"))\n         .andExpect(model().attribute(\"studentsList\", hasItem(is(student))))\n         .andReturn();\n}\nSpring Boot Tests\nUnit Test : Controller layer\nOur Controller depends on the Service layer.\nBut since we're only focused on the Controller code, it's natural to mock the Service layer code for our unit tests.\nTo test the Controllers, we can use @WebMvcTest. \n@WebMvcTest auto-configures MockMvc, which offers a powerful way of easily testing MVC controllers without starting a full HTTP server.\nWe can use it along with @MockBean to provide mock implementations for any required dependencies.\nSpring Boot Tests\nUnit Test : Controller layer\n@WebMvcTest(StudentController.class)\nclass StudentControllerTest {\n\n @Autowired\n private MockMvc mockMvc;\n @MockBean\n private StudentRepository studentRepository;\n\n @Test\n public void itShouldGetAllStudents() throws Exception {\n\n // given\n Student student = new Student(\"sara\", \"bayour\", \"sara@nttdata.com\");\n given(studentService.getAllStudents()).willReturn(Arrays.asList(student));\n\n // when\n ResultActions resultActions = mockMvc.perform(get(\"/students\"));\n\n // then\n resultActions.andExpect(status().is2xxSuccessful())\n         .andExpect(view().name(\"students\"))\n         .andExpect(model().attribute(\"studentsList\",hasItem(is(student))))\n}\n}\nSpring Boot Tests\nUnit Test : Controller layer\nThe get(…) method call can be replaced by other methods corresponding to HTTP verbs like put(), post(), etc.\nMockMvc is flexible, and we can create any request using it.\n\nSpring Boot Tests\nUnit Test : Service layer\nThe services depend on the persistence layer\nHowever, to test the Service layer, we don't need to know or care about how the persistence layer is implemented. Ideally, we should be able to write and test our Service layer code without wiring in our full persistence layer.\nTo achieve this, we can use the mocking support provided by Spring Boot Test.\nLet's have a look at the test class skeleton first:\n\n@ExtendWith(MockitoExtension.class)\nclass StudentServiceTest {\n\n @Mock\n private StudentRepository studentRepository;\n\n @InjectMocks\n private StudentServiceImpl studentService;\n\n // write test cases here\n\n}\nSpring Boot Tests\nUnit Test : Service layer\n\n\nThe @Mock annotation specifies the fields in which Mockito should inject mock objects. \nThe @MockitoExtension tells Mockito to evaluate those @Mock annotations because JUnit does not do this automatically.\nOn the other hand @InjectMocks, creates objects and inject the mocked dependencies annotated with @Mock\n⇒ Use @InjectMocks when we need all internal dependencies to be initialised with mock objects too.\n\nSpring Boot Tests\nUnit Test : Service layer\n\nThe Test should look like this :\n\n@Test\nvoid itShouldGetAllStudents() {\n // given\n Student student = new Student(\"sara\", \"bayour\", \"sara@nttdata.com\");\n Mockito.when(studentRepository.findAll()).thenReturn(Arrays.asList(student));\n\n // when\n List<Student> students = studentService.getAllStudents();\n\n //then\n Assertions.assertThat(students).contains(student);\n}\nSpring Boot Tests\nUnit Test : Persistence layer\n\nTo test our Repository we can use the @DataJpaTest annotation\n@DataJpaTest provides some standard setup needed for testing the persistence layer:\nconfiguring H2, an in-memory database\nsetting Hibernate, Spring Data, and the DataSource\nperforming an @EntityScan\nturning on SQL logging\nSpring Boot Tests\nUnit Test : Persistence layer\n@DataJpaTest\nclass StudentRepositoryTest {\n\n @Autowired\n private StudentRepository studentRepository;\n\n @Test\n void itShouldFindStudentWithEmail() {\n // given\n String email = \"sara@nttdata.com\";\n Student student = new Student(\"sara\", \"bayour\", email);\n studentRepository.save(student);\n\n // when\n List<Student> students = studentRepository.findByEmail(email);\n\n\n // then\n Assertions.assertThat(students).hasSize(1);\n   }\n}\nSpring Boot Tests\nUnit Test : Persistence layer\nIn the previous test, we start by inserting a new student in the DB,  then reading it via the findByXXX API.\nThe assertThat(…) part comes from the Assertj library, which comes bundled with Spring Boot.\nSpring Boot Tests\nPlan: \n\nWhy Spring Boot?\nSpring vs Spring Boot\nSpring Boot Annotations\nSpring Boot Starters\nDemo (Spring Setup)\nTests\nDemo (Tests)\nMaterials & documentation\nDEMO\nPlan: \n\nWhy Spring Boot?\nSpring vs Spring Boot\nSpring Boot Annotations\nSpring Boot Starters\nDemo (Spring Setup)\nTests\nDemo (Tests)\nMaterials & documentation\nhttps://docs.spring.io/spring-boot/docs/2.0.x/reference/html/index.html\nhttps://www.baeldung.com/spring-boot\nhttps://www.javatpoint.com/spring-boot-annotations\nhttps://dzone.com/articles/unit-and-integration-tests-in-spring-boot-2\n\nMaterials & Documentation\nThank you\n\n"
}