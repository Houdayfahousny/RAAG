 
 

Plan: 

Why Spring Boot?
Spring vs Spring Boot
Spring Boot Annotations
Spring Boot Starters
Demo (Spring Setup)
Tests
Demo (Tests)
Materials & documentation
Plan: 

Why Spring Boot?
Spring vs Spring Boot
Spring Boot Annotations
Spring Boot Starters
Demo (Spring Setup)
Tests
Demo (Tests)
Materials & documentation

You can choose Spring Boot because of the features and benefits it offers :
Create stand-alone Spring applications
To avoid complex XML configuration in Spring
To develop a production ready Spring applications in an easier way
In Spring Boot, everything is auto configured (no manual configurations are needed).
It offers annotation-based spring application
Eases dependency management
Provide starter dependencies to simplify your build configuration
It includes an Embedded Servlet Container (Tomcat)
Reduces the development time
Provide production-ready features such as metrics, health checks, and externalised configuration
Why Spring Boot?
Plan: 

Why Spring Boot?
Spring vs Spring Boot
Spring Boot Annotations
Spring Boot Starters
Demo (Spring Setup)
Tests
Demo (Tests)
Materials & documentation
Definition : Spring vs Spring Boot


Spring :
To put it simply, the Spring framework provides comprehensive infrastructure support for developing Java applications.
It's packed with some useful features like Dependency Injection, and out of the box modules, that can drastically reduce the development time of an application, like: Spring MVC, Spring Test, Spring Security..

Spring vs Spring Boot
Definition : Spring vs Spring Boot


Spring Boot :
On the other hand, Spring Boot is basically an extension of the Spring framework, which eliminates the boilerplate configurations required for setting up a Spring application.
Since Spring Boot is built on top of Spring, it offers all the features and benefits of Spring. 
Spring Boot aims to reduce code length and provides developers with the easiest way to build an application.
Spring vs Spring Boot
Dependencies : Spring vs Spring Boot


Spring :
the minimum dependencies required to create a web application using Spring are :

<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-web</artifactId>
    <version>x.x.x</version>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-webmvc</artifactId>
    <version>x.x.x</version>
</dependency>

Spring vs Spring Boot
Dependencies : Spring vs Spring Boot


Spring Boot :

Spring Boot requires only one dependency to get a web application up and running :

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
    <version>x.x.x</version>
</dependency>
Spring vs Spring Boot
Bootstrapping : Spring vs Spring Boot


Spring :
Spring supports both the legacy web.xml way of bootstrapping as well as the Servlet method.
XML approach (web.xml) :
Servlet container (the server) reads web.xml.
The DispatcherServlet defined in the web.xml is instantiated by the container.
DispatcherServlet creates WebApplicationContext by reading WEB-INF/{dispatcherServletName}-servlet.xml.
Finally, the DispatcherServlet registers the beans defined in the application context.
Java approach : 
The container searches for classes implementing ServletContainerInitializer ⇒ SpringServletContainerInitializer 
The SpringServletContainerInitializer class (which implements ServletContainerInitializer) finds all classes implementing WebApplicationInitializer.
The WebApplicationInitializer creates the context with XML or @Configuration classes.
The WebApplicationInitializer creates the DispatcherServlet with the previously created context.
		⇒ https://www.codejava.net/frameworks/spring/bootstrapping-a-spring-web-mvc-application-programmatically 
Spring vs Spring Boot
Bootstrapping : Spring vs Spring Boot

Spring Boot :
The entry point of a Spring Boot application is the class which is annotated with @SpringBootApplication.
By default, Spring Boot uses an embedded container to run the application. In this case, Spring Boot uses the public static void main entry point to launch an embedded web server.
Another feature of Spring Boot is that it automatically scans all the classes in the same package or sub packages of the Main-class, for components.

Spring vs Spring Boot
Plan: 

Why Spring Boot?
Spring vs Spring Boot
Spring Boot Annotations
Spring Boot Starters
Demo (Spring Setup)
Tests
Demo (Tests)
Materials & documentation

Spring Boot Annotations is a form of metadata that provides data about a program. 
In other words, annotations are used to provide supplemental information about a program. 

Spring Boot Annotations
@SpringBootApplication

It’s an essential annotation to all Spring Boot applications.
@SpringBootApplication replaces several other key annotations :
@Configuration
@ComponentScan
@EnableAutoConfiguration

The class annotated with @SpringBootApplication is kept in the base package. 
This annotation does the component scan. However, only the sub-packages are scanned. 
Spring Boot Annotations
@Configuration
Now replaced by @SpringBootApplication
@Configuration enables Java configuration and lets you use Spring Beans in the class.
A class annotated with the @Configuration annotation indicates that this class declares one or more @Bean
Spring Boot Annotations
@ComponentScan
Also replaced by @SpringBootApplication
@ComponentScan is used to scan a package for beans.
It is used with the annotation @Configuration to allow Spring to know the packages to be scanned for annotated components. So that they can be automatically discovered and registered as beans in Spring's Application Context.
This annotation is also used to specify base packages.
Spring Boot Annotations
@EnableAutoConfiguration
The final annotation replaced by @SpringBootApplication
@EnableAutoConfiguration enables Spring Boot’s auto configuration. 
It is placed in the main application class. 
Based on the dependencies in the classpath, other beans, and various property settings, this annotation instructs Spring Boot to start adding beans.
Spring Boot Annotations
@Component
It is a class-level annotation that turns the class into Spring bean at the auto-scan time.
@Repository, @Controller, and @Service are move specific alternatives to @Component.
Spring Boot Annotations
@Service
It is used at the class level. 
It shows that the annotated class is part of your service layer, that contains business basic logic, and may include calls to external APIs. 
Spring Boot Annotations
@Repository
This annotation marks a class as part of your persistence layer
It is a Data Access Object (DAO) that accesses the database directly to handle storage, retrieval, and search of data. 
Spring Boot Annotations
@Controller
The annotation is used to indicate that the class is a web request handler.
@Controller is a specialised @Component marked as a controller in the MVC architecture. 
It is most commonly used with @RequestMapping annotation. 
Spring Boot Annotations
@RequestBody 
The @RequestBody annotation maps the HttpRequest body to an object, enabling automatic deserialization of the inbound HttpRequest body onto a Java object.
By default, the type we annotate with the @RequestBody annotation must correspond to the JSON sent from our client-side controller.
Spring Boot Annotations
@ResponseBody 
The @ResponseBody annotation tells a controller that the object returned is automatically serialized into JSON and passed back into the HttpResponse object.
Spring Boot Annotations
@RestController 
@RestController is a specialized version of the controller. It includes the @Controller and @ResponseBody annotations.
@RestController classes return objects instead of views.
So every request handling method of the controller class, automatically serializes returned objects into HttpResponse.
Spring Boot Annotations
@RequestParam 
It is used to extract the query parameters from the URL. 
It can specify default values if the query parameter is not present in the URL (if it’s not a required parameter).
Example : http://localhost:8080/employees/search?id=123&name=sara

Spring Boot Annotations
@PathVariable 
It is used to extract the values from the URL. 
It is most suitable for the RESTful web service, where the URL contains a path variable. 
We can define multiple @PathVariable in a method.
Example : http://localhost:8080/employees/search/123/test/
Spring Boot Annotations
@RequestHeader 
It is used to get the details about the HTTP request headers. 
We use this annotation as a method parameter. 
We can use it multiple time in a method
Example : Content-Type, Accept, Authorization..
Spring Boot Annotations
Plan: 

Why Spring Boot?
Spring vs Spring Boot
Spring Boot Annotations
Spring Boot Starters
Demo (Spring Setup)
Tests
Demo (Tests)
Materials & documentation
The starters allow us to add jars in the classpath and they make development easier and rapid. 
Spring Boot Starters are dependency descriptors that can be added under the <dependencies> section in pom.xml. 
In the Spring Boot Framework, all the starters follow a similar naming pattern: spring-boot-starter-*, where * denotes a particular type of application. 
⇒ For example, if we want to use Spring and JPA for database access, we need to include the spring-boot-starter-data-jpa dependency in our pom.xml file of the project.
Spring Boot Starters
The advantages of using Starters are as follows:
Increase productivity by decreasing the Configuration time for developers.
Managing the POM is easier since the number of dependencies to be added is decreased.
Tested, Production-ready, and supported dependency configurations.
No need to remember the name and version of the dependencies.
Spring Boot Starters
Spring Boot Starter Parent
The spring-boot-starter-parent project is a special starter project that provides default configurations for our application (like Java version) and a complete dependency tree to quickly build our Spring Boot project. 
It also provides default configurations for Maven plugins, such as maven-jar-plugin and maven-war-plugin.
Beyond that, it also inherits dependency management from spring-boot-dependencies, which is the parent to the spring-boot-starter-parent.
We can start using it in our project by adding it as a parent in our project's pom.xml:
<parent>  
<groupId>org.springframework.boot</groupId>  
<artifactId>spring-boot-starter-parent</artifactId>  
<version>2.x.x</version>  <!-- Spring Boot version -->
</parent>  
Spring Boot Starters
Spring Boot Starter Web
If we want to develop a web application, we need to add the starter spring-boot-starter-web
<dependency>  
<groupId>org.springframework.boot</groupId>  
<artifactId>spring-boot-starter-web</artifactId>  
</dependency>  

The Starter of Spring web uses Spring MVC, REST and Tomcat (as a default embedded server). 

Spring Boot Starters
Spring Boot Starter Web
The single spring-boot-starter-web dependency pulls in all dependencies related to web development :
org.springframework.boot:spring-boot-starter
org.springframework.boot:spring-boot-starter-tomcat
org.springframework.boot:spring-boot-starter-json
org.springframework:spring-web
org.springframework:spring-webmvc
Spring Boot Starters
Spring Boot Starter Data JPA
To connect Spring applications with relational databases efficiently, Spring Boot provides spring-boot-starter-data-jpa dependency . 
The spring-boot-starter-data-jpa internally uses the spring-data-jpa dependency.
<dependency>  
<groupId>org.springframework.boot</groupId>  
<artifactId>spring-boot-starter-data-jpa</artifactId>  
</dependency>  

Spring Boot Starters
Spring Boot Starter Actuator
Spring Boot Actuator provides a number of features that help you ensure that your application is running well in production.
Monitoring our app, gathering metrics, understanding traffic, or the state of our database become trivial with this dependency.
The main benefit of this library is that we can get production-grade tools without having to actually implement these features ourselves.
Actuator is mainly used to expose operational information about the running application through HTTP endpoints or JMX beans.

Spring Boot Starters
Spring Boot Starter Actuator
Most applications choose exposure via HTTP, where the ID of the endpoint along with a prefix of /actuator is mapped to a URL. 
Spring Boot includes a number of built-in endpoints and lets you add your own. 
⇒ For example, the health endpoint that is  mapped to /actuator/health, provides basic application health information. ( List of available endpoints https://docs.spring.io/spring-boot/docs/3.0.x/reference/html/actuator.html#actuator.endpoints )
To enable Spring Boot Actuator, we just need to add the spring-boot-actuator dependency to our package manager.
<dependency>  
<groupId>org.springframework.boot</groupId>  
<artifactId>spring-boot-starter-actuator</artifactId>  
</dependency>  
   
Spring Boot Starters
Spring Boot Starter Test
There are several different types of tests that we can write to help test and automate the health of an application. But before starting any testing, we need to integrate the testing framework.
The spring-boot-starter-test is the primary dependency for the test. It contains the majority of elements required for our tests.
With Spring Boot, we need to add a starter to our project : the spring-boot-starter-test dependency.
<dependency>  
<groupId>org.springframework.boot</groupId>  
<artifactId>spring-boot-starter-test</artifactId>  
<scope>test</scope>  
</dependency>  
Spring Boot Starters
Spring Boot Starter Test
The spring-boot-starter-test dependency, pulls all the dependencies related to the test. After adding it, we can build up a simple unit test.
In the previous dependency, one thing to be noticed is that it includes the scope of test <scope>test</scope>. 
It means when the application is bundled and packaged for deployment, any dependency that is declared with the test scopes is ignored.
Note :
When we create a simple Spring Boot application, by default, it contains the test dependency in the pom.xml file and ApplicationNameTest.java file under in the folder src/test/java.
Spring Boot Starters
Plan: 

Why Spring Boot?
Spring vs Spring Boot
Spring Boot Annotations
Spring Boot Starters
Demo (Spring Setup)
Tests
Demo (Tests)
Materials & documentation
DEMO
Plan: 

Why Spring Boot?
Spring vs Spring Boot
Spring Boot Annotations
Spring Boot Starters
Demo (Spring Setup)
Tests
Demo (Tests)
Materials & documentation
Integration Tests
Integration tests focus on integrating different layers of the application. That also means no mocking is involved.
Ideally, we should keep the integration tests separated from the unit tests and should not run along with the unit tests. 
⇒ We can do this by using a different profile to only run the integration tests. 
A couple of reasons for doing this could be that the integration tests are time-consuming and might need an actual database to execute.
The integration tests need to start up a container to execute the test cases. Hence, some additional setup is required for this. But all of this is easy in Spring Boot.
Spring Boot Tests
Integration Tests
@SpringBootTest
@AutoConfigureMockMvc
@TestPropertySource(locations = "classpath:application-integrationtest.properties")
class StudentControllerITest {

 @Autowired
 private MockMvc mockMvc;

 @Autowired
 private StudentRepository studentRepository;
    // write test cases here
}
Spring Boot Tests
Integration Tests
The @SpringBootTest annotation is useful when we need to bootstrap the entire container. It works by creating the ApplicationContext that will be utilised in our tests.
The @AutoConfigureMockMvc annotation enables all auto-configuration related to MockMvc.
The @TestPropertySource annotation helps configure the locations of properties files specific to our tests. 
⇒ Note that the property file loaded with @TestPropertySource will override the existing application.properties file.
The application-integrationtest.properties contains the details to configure the persistence storage :
spring.datasource.url = jdbc:h2:mem:testIntegration
spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.H2Dialect
If we want to run our integration tests against another Database ex: MySQL, we can just change the above values in the properties file.
Spring Boot Tests
Integration Tests
The test cases for the integration tests might look similar to the Controller layer unit tests :
@Test
public void itShouldGetAllStudents() throws Exception {

 // given
 Student student = new Student("sara", "bayour", "sara@nttdata.com");
 studentRepository.save(student);

 // when
 ResultActions resultActions = mockMvc.perform(get("/students"));

 // then
 MvcResult result = resultActions.andExpect(status().is2xxSuccessful())
         .andExpect(view().name("students"))
         .andExpect(model().attribute("studentsList", hasItem(is(student))))
         .andReturn();
}
Spring Boot Tests
Unit Test : Controller layer
Our Controller depends on the Service layer.
But since we're only focused on the Controller code, it's natural to mock the Service layer code for our unit tests.
To test the Controllers, we can use @WebMvcTest. 
@WebMvcTest auto-configures MockMvc, which offers a powerful way of easily testing MVC controllers without starting a full HTTP server.
We can use it along with @MockBean to provide mock implementations for any required dependencies.
Spring Boot Tests
Unit Test : Controller layer
@WebMvcTest(StudentController.class)
class StudentControllerTest {

 @Autowired
 private MockMvc mockMvc;
 @MockBean
 private StudentRepository studentRepository;

 @Test
 public void itShouldGetAllStudents() throws Exception {

 // given
 Student student = new Student("sara", "bayour", "sara@nttdata.com");
 given(studentService.getAllStudents()).willReturn(Arrays.asList(student));

 // when
 ResultActions resultActions = mockMvc.perform(get("/students"));

 // then
 resultActions.andExpect(status().is2xxSuccessful())
         .andExpect(view().name("students"))
         .andExpect(model().attribute("studentsList",hasItem(is(student))))
}
}
Spring Boot Tests
Unit Test : Controller layer
The get(…) method call can be replaced by other methods corresponding to HTTP verbs like put(), post(), etc.
MockMvc is flexible, and we can create any request using it.

Spring Boot Tests
Unit Test : Service layer
The services depend on the persistence layer
However, to test the Service layer, we don't need to know or care about how the persistence layer is implemented. Ideally, we should be able to write and test our Service layer code without wiring in our full persistence layer.
To achieve this, we can use the mocking support provided by Spring Boot Test.
Let's have a look at the test class skeleton first:

@ExtendWith(MockitoExtension.class)
class StudentServiceTest {

 @Mock
 private StudentRepository studentRepository;

 @InjectMocks
 private StudentServiceImpl studentService;

 // write test cases here

}
Spring Boot Tests
Unit Test : Service layer


The @Mock annotation specifies the fields in which Mockito should inject mock objects. 
The @MockitoExtension tells Mockito to evaluate those @Mock annotations because JUnit does not do this automatically.
On the other hand @InjectMocks, creates objects and inject the mocked dependencies annotated with @Mock
⇒ Use @InjectMocks when we need all internal dependencies to be initialised with mock objects too.

Spring Boot Tests
Unit Test : Service layer

The Test should look like this :

@Test
void itShouldGetAllStudents() {
 // given
 Student student = new Student("sara", "bayour", "sara@nttdata.com");
 Mockito.when(studentRepository.findAll()).thenReturn(Arrays.asList(student));

 // when
 List<Student> students = studentService.getAllStudents();

 //then
 Assertions.assertThat(students).contains(student);
}
Spring Boot Tests
Unit Test : Persistence layer

To test our Repository we can use the @DataJpaTest annotation
@DataJpaTest provides some standard setup needed for testing the persistence layer:
configuring H2, an in-memory database
setting Hibernate, Spring Data, and the DataSource
performing an @EntityScan
turning on SQL logging
Spring Boot Tests
Unit Test : Persistence layer
@DataJpaTest
class StudentRepositoryTest {

 @Autowired
 private StudentRepository studentRepository;

 @Test
 void itShouldFindStudentWithEmail() {
 // given
 String email = "sara@nttdata.com";
 Student student = new Student("sara", "bayour", email);
 studentRepository.save(student);

 // when
 List<Student> students = studentRepository.findByEmail(email);


 // then
 Assertions.assertThat(students).hasSize(1);
   }
}
Spring Boot Tests
Unit Test : Persistence layer
In the previous test, we start by inserting a new student in the DB,  then reading it via the findByXXX API.
The assertThat(…) part comes from the Assertj library, which comes bundled with Spring Boot.
Spring Boot Tests
Plan: 

Why Spring Boot?
Spring vs Spring Boot
Spring Boot Annotations
Spring Boot Starters
Demo (Spring Setup)
Tests
Demo (Tests)
Materials & documentation
DEMO
Plan: 

Why Spring Boot?
Spring vs Spring Boot
Spring Boot Annotations
Spring Boot Starters
Demo (Spring Setup)
Tests
Demo (Tests)
Materials & documentation
https://docs.spring.io/spring-boot/docs/2.0.x/reference/html/index.html
https://www.baeldung.com/spring-boot
https://www.javatpoint.com/spring-boot-annotations
https://dzone.com/articles/unit-and-integration-tests-in-spring-boot-2

Materials & Documentation
Thank you

