


TECHNICAL TRAININGS
Java EE / Spring
TYPE
Online Course
CONTENTS
Java EE Architecture Overview
Spring Framework
Spring vs Java EE
Spring Modules
Spring Modules Overview
Spring Core
Spring AOP
Spring Batch
Spring MVC
Spring Security
Spring Core
IOC / Dependency Injection
Constructor/ Setter/ Field Dependency injection
BeanFactory
ApplicationContext
Bean lifecycle
Bean scopes
Xml Configuration
Annotation Based Configuration
Essential Spring Annotations
@Configuration
@ComponentScan
@Import
@ImportResource
@PropertySource
@Value
@Bean
@Component @Service @Repository @Controller
@Autowired
@Qualifier 
@Primary 
@Lazy 
@Transactional



DURATION
2 hours
BASIC INFORMATION
LANGUAGES
English, Arabic
PREREQUISITES
Java Knowledge
CATEGORIES 
CJ– CD – CD2 (JAVA)
OBJECTIVES

	Understand the big picture of Java EE Architecture and it’s components
	Understand differences between Java EE and Spring
Understand the reasons behind the development of Spring framework
	Understand the big picture around Spring Core, Spring AOP, Spring MVC, Spring Security, Spring Batch modules 
	Deep Dive into Spring Core module
	Understand essential Spring annotations



INTRODUCTION
Java Enterprise Edition
A Provider that implements these specifications, must meet certain conformance requirements in order to be certified  Full or Web Jakarta EE compliant.

Example of Java EE Certified Full Compliant : 
Oracle WebLogic Server
Oracle Glassfish
IBM WebSphere Application Server Liberty
Redhat Wildfly
JBoss Enterprise Application Platform



A set of specifications for enterprise application features : 

Web specifications : 
Java Servlet
Java Server Faces
Java Expression Language
Web service specifications : 
Java RESTful Web Services
Java JSON Processing
Java XML Binding
Java XML Web Services
Enterprise specifications : 
Enterprise Java Beans
Java Persistence API
Java Transaction API
Java Messaging Service
Other specifications : 
Java Batch
Validation
Java EE Architecture – Java EE Containers

Java EE Architecture – Web Container
Also named Servlet Container

Manage the lifecycle of servlets

Handle Servlet requests / responses

Dynamically generates HTML pages from JSP files

Example : Apache Tomcat, and all Full JavaEE Implementations (Weblogic, Wildfly, Websphere …)
Java EE Architecture – EJB Container
Manage Lifecycle of EJB Beans

 Manage the binding of EJB beans to the naming for remote access to them

Transaction management

Manages a pool of bean instances

Handles Security



Spring Framework
Initially Developed by Rod Johnson and released in 2004 v1.0 (first prod release)

Developed based on the principles of dependency injection (DI) and inversion of control (IoC)

Over the years more modules was added to provide services like Aspect-oriented programming, Data access, Transaction management, Model–view–controller, Authentication and authorization, and Testing

The goal of it’s first development was to overcome drawbacks encountered in J2EE

Spring came as an alternative to EJB

Enables developers to develop enterprise-class applications using POJOs

You do not need an EJB container product such as an application server but you have the option of using only a robust servlet container such as Tomcat or some commercial product.

Lightweight IoC containers , especially when compared to EJB containers

In EJB / Servlet, need to extend some classes, in Spring we use only POJO

Spring lightweight container, depend only on JDK and Spring Jars => Platform independent

EJB heavyweight depend on Application Server, and application server depend on OS

Spring Framework – J2EE drawbacks
Drawbacks encountered in EJB 2.x specification : 

The business logic implementation class must implement an interface from the EJB framework package : 
 	=> Tight coupling between the developer-written code and the interface classes from the EJB framework package.

implementation of several unnecessary callback methods (ejbCreate, ejbPassivate, ejbActivate) not directly related to the main design goal of the EJB

EJB 2.X deployment descriptors are verbose, complex, and error prone

EJBs are difficult to test, since the application needs a J2EE container to provide all the services required to correctly run the EJB component






Spring Version History
Spring Modules - Overview
Features of Spring framework are organized into Modules

Spring modules are grouped based on their primary features (Data Access/ Integration, Web, Core, AOP, Test)

Spring Core

Spring Core container module implements IoC using Dependency Injection

BeanFactory interface is the representation of the Spring IoC container that is responsible for containing and  managing the beans.

A Bean is an object created / managed by Spring IOC container

Spring IoC container consumes some form of configuration metadata

Configuration metadata (XML / Annotations) is how you inform the Spring container as to how to “instantiate, configure, and assemble [the objects in your application (beans)]



Spring AOP

AOP (Aspect Oriented Programming) : 

Programming paradigm that allow the separation of cross cutting concerns from the business concerns
Transaction management is an example of cross cutting concern


Cross cutting concern :
Functionality needed in many places of the application 

Examples : 
Logging (log before/after method call)
Transaction management (begin/commit)
Security (role check before method call)
Spring AOP
AOP Concepts : 

Aspect : 
a modularization of a concern that cuts across multiple classes.
Join point : 
A point during the execution of a program, In Spring AOP, a join point always represents a method execution.
Advice : 
Action taken by an aspect at a particular join point
Advice types : 
"around," "before" and "after“
Pointcut : 
A predicate that matches join points. Advice is associated with a pointcut expression and runs at any join point matched by the pointcut
Target Object : 
proxied object being advised by one or more aspects
AOP Proxy : 
object created by the AOP framework in order to implement the aspect contracts (advise method executions and so on)
Weaving : 
linking aspects with other application types or objects to create an advised object
Spring Batch
Framework for developing batch applications

Provides reusable functions that are essential in processing large volumes of records, including logging/tracing, transaction management, job processing statistics, job restart, skip, 

Application Layer : 
contains batch jobs written by developers using Spring Batch

Core Layer : 
contains the core runtime classes necessary to launch and control a batch job.
It includes implementations for JobLauncher, Job, and Step

Infrastructure Layer : 
contains common readers and writers and services (like RetryTemplate), which are used both by application developers (like ItemReader, ItemWriter), and the core framework (like retry)


Typical Batch program : 
	1) Reads a large number of records from a database, file, or queue.
	2) Process the data in some fashion
	3) Writes back data in a modified form
Spring MVC
Figure : Request Processing Workflow
Provide Model-View-Controller architecture : 

Model : encapsulate the application data

View : render the model data

Controller : process user requests, build the model after calling business service(s), and pass it to the view for rendering

Dispatcher Servlet (Front Controller): 
handles all the HTTP requests and responses.
Spring Security
Provide support for authentication and authorization

Provide protection against common attacks

provides a default set of security related HTTP response headers to provide secure defaults

The default for Spring Security is to include the following headers in the http response :





Spring Core – IOC / Dependency Injection
Inversion of control is a design principle that allows classes to be loosely coupled and, therefore, easier to test and maintain.

The control of objects and their dependencies is transferred from the main program to a container or framework

Dependency Injection is an implementation of the IOC design principle

The Spring container instantiates and manages the lifecycle of the objects that are a part of the program

The developer provides the information related to what objects and dependencies are required by the application

Benefits of IOC : 
Reduces amount of application code
Decreases coupling between classes
Makes the application easier to test and maintain








Dependency Injection
IOC Container
Inversion of Control
Principle 
Pattern
Framework
Constructor dependency injection
Is the recommended way of dependency injection in Spring

From Spring 4.3, classes with a single constructor can omit the @Autowired annotation

Testability : no need to mock dependencies

All required dependencies are available at initialization time 
IOC container make sure all constructor arguments are available before passing them to constructor

Design for immutability : 
=> Mark dependencies final
Secure behavior of beans (dependencies can’t be changed later) => unflexibility to take into account
When refactoring, detect errors after refactoring at compile time

Loose coupling with the DI container

Setter dependency injection
Use of @Autowired on setter methods

Poor readability of the code

Required use of @Autowired => tight coopling between the code and the DI container



Field dependency injection
Fields of the class are annotated with @Autowired

The code is more clean with field injection, avoids boilerplate code (setter), and no need to declare constructor

Don’t work with final (Immutable) fields
	=> final fields must be instantiated at class instantiation
	=> The field injection runs after class instantiation


Required use of @Autowired => tight coopling between the class code and the DI container




BeanFactory
The root interface for accessing a Spring bean container

Manage the beans and their dependencies

Use a configuration registry (xml file) for creating beans and injecting the dependencies between them

supports only Singleton and Prototype bean scopes

does not support Annotations for autowiring
	=> need to use autowire attribute in XML

does not provides i18n / internationalization functionality.

instantiate beans only when you call getBean() method(s) : 

leads to not detecting configuration errors at startup
This problem is solved in ApplicationContext implementations, where it instantiate all singleton beans at startup



ApplicationContext
ApplicationContext is a sub-interface of the BeanFactory

ApplicationContext allow Java configuration in addition to XML configuration

ApplicationContext is mostly used in production applications


Additional features of ApplicationContext : 

Message resolution and Internationalization : 

Provide ResourceBundleMessageSource implementation of MessageSource interface, that allow us for example to create different properties files for each language messages, and we load the translated message based on the actual local of the client that sent the request to our backend application

Event publishing : 
Ability to publish events to beans registred as listeners (example : ContextStartedEvent, ContextStoppedEvent)
provided through the ApplicationEvent class and ApplicationListener interface

BeanFactory
ApplicationContext
ClassPathXmlApplication
Context
FileSystem
Xml
Application
Context
Annotation
Config
Application
Context
Bean Lifecycle
- 
Bean scopes
Singleton : 
Is the default scope, one single instance is created per application context

Prototype : 
A different bean instance is returned every time it is requested from the container.

Request : 
creates a bean instance for a single HTTP request

Session : 
 creates a bean instance for an HTTP Session.

Application : 
creates the bean instance for the lifecycle of a ServletContext

Websocket : 
creates the bean instance for a particular WebSocket session




Xml Based configuration
Is the first provided Spring configuration style when it was born

We create an xml file specifying the spring xml schema inside <beans> tag

We declare our beans and the dependencies between them inside <bean> tags

Xml configuration files grow and become difficult to maintain, and error prone

We can’t detect type errors at compile time

Difficulty in maintenance of large xml files


Annotation based configuration
From Spring 2.5 it became possible to configure the dependency injection using annotations

Bean wiring is configured using annotations

<context:annotation-config> :  used to process annotations in beans already registered in the application context

<context:component-scan> : in addition to what <context:annotation-config> do, it also scan packages to find and register beans within the applicationcontext

Annotation injection is performed before XML injection
The xml configuration overrides the annotation configuration in case they are similar

  Need to enable annotation wiring in the xml configuration file using either <context:annotation-config> or <context:component-scan> 

Java based configuration
Enables to write the Spring configuration without using xml 

Annotating a class with the @Configuration indicates that the class can be used by the Spring IoC container as a source of bean definitions

The @Bean annotation tells Spring that a method annotated with @Bean will return an object that should be registered as a bean in the Spring application context

We create the ApplicationContext with the implementation AnnotationConfigApplicationContext that we give it as parameter the base configuration class

We can register as many configuration classes as we want with the register() method of AnnotationConfigApplicationContext 




Spring Annotations - @Configuration


Used over a class to tell it’s a spring configuration class that contains @Bean definition methods

Can be used also with @ComponentScan to scan candidates for bean creation


Spring Annotations - @ComponentScan

Used along with the @Configuration annotation to specify the packages that we want to be scanned

If used without arguments, the current package in which the class annotated with @ComponentScan is present, and all it’s subpackages are scanned

Example : 


	@ComponentScan(basePackages = {"com.example.util”, “com.example.service”})

	@ComponentScan(basePackages = "com.example.util , com.example.service")

@ComponentScan(basePackages = "com.example.util ; com.example.service")

@ComponentScan(basePackages = "com.example.util com.example.service")

@ComponentScan(basePackages = {"com.example.util com.example.service"})

Spring Annotations - @Import
Indicates one or more component classes to import — typically @Configuration classes 

 Useful when we want to group multiple configuration classes into one

Accept @Component classes (@Configuration also as it inherit from @Component)

Can be used together with @ComponentScan to improve performance of application startup, while loading only some groups of bean configuration

Example : 

















package com.hr.service;
 
@Configuration 
@ComponentScan 
public class HrServiceConfiguration {
 }
package com.hr;

@Configuration 
@Import(HrServiceConfiguration.class)
public class HrConfiguration {
 }
Spring Annotations - @PropertySource
Introduced in Spring 3.1

Used with @Configuration for registering properties file(s) in the application Environment

Not supported when we use YAML files for properties

In Spring Boot convention, if we put application.properties under src/main/resources it is automatically detected without need of @PropertySource


@Configuration @PropertySource("classpath:app.properties")    public class MainConfig {
 
 }
// Using Java 8 repeatable annotation

@PropertySource("classpath:app.properties") @PropertySource("classpath:database.properties")
@Configuration
 public class MainConfig {

}
Spring Annotations - @Value
Used to inject values into fields in Spring managed beans

Generally, we use it to inject values from properties file(s) registered in the environment

We can also inject raw values

Can be applied at the field or constructor / method parameter level


@Value(“raw value") 
private String rawValue;
@Value("${value.from.properties.file}") 
private String valueFromPropertiesFile;
@Value("${value.from.properties.file: defaultValue}") 
private String valueFromPropertiesFile;
Spring Annotations - @Qualifier
Solve the problem when Spring doesn’t know which bean to inject

Problem Case : 
We have multiple beans of the same type in the application context
Spring by default resolve the autowired entries by type
Spring throw NoUniqueBeanDefinitionException



@Service
public class CustomerServiceImpl implements      CustomerService { 

   @Autowired 
   @Qualifier(“nttSmsService") 
   private SmsService smsService; 

}
@Component(“nttSmsService”)
public class NttSmsService implements SmsService{

    // …. 
   
}
Spring Annotations - @Primary
Introduced in Spring 3.0

Used to give higher preference to a bean when there are multiple beans of the same type

Used specifically in following cases : 

Case 1 : We declare multiple beans of same type in @Configuration classes, in which case @Qualifier will not solve the issue

Case 2 : We use @ComponentScan over a configuration class, and we declare multiple @Component of the same type in the package candidate for scan

Useful when we want to specify which bean of a certain type should be injected by default

If both the @Qualifier and @Primary annotations are present, then the @Qualifier annotation will have precedence


Spring Annotations - @Lazy
Spring by default creates all singleton beans eagerly at startup of the application context
Earlier detection of possible errors

@Lazy is used when we want to initialize a bean that we know is rarely used in the application





@Lazy
@Configuration
public class MainConfig {
    // All beans defined here will be lazily loaded      
 }
@Lazy
@Component
public class RarelyUsedService{
 }
@Service
public class CustomerServiceImpl implements CustomerService{
    @Lazy
    @Autowired
    private RarelyUsedService rarelyUsedService;
    
 }
Spring Annotations - @Transactional
Is the declarative approach to manage transactions with Spring

Can be used on class or method level

Spring creates proxies for all the classes annotated or containing in method level @Transactional annotation

The Proxy allow Spring to inject transactional logic before and after the running method

By default the rollback of the transaction happens when runtime exceptions or errors occur

We can manage rollback rules by using rollbackFor and noRollbackFor




If the Transactional bean is implementing an interface : 
         => only external method calls of the transactional method will start a transaction
         => In this specific case don’t call the transactional method from a method within the same class
         => This is a limitation of the Java Dynamic Proxy created by Spring for Bean classes that implement     	interfaces (only external method calls that come in through the proxy will be intercepted)
Only public methods should be annotated with @Transactional
         
